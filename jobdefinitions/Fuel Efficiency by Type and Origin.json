{"creationTimeStamp":"2023-08-28T06:19:13.615Z","modifiedTimeStamp":"2023-08-28T06:29:47.637Z","createdBy":"student","modifiedBy":"student","version":2,"id":"b4d3cd6e-186d-48ff-909d-53e351280dbb","name":"Fuel Efficiency by Type and Origin","description":"","type":"Compute","parameters":[{"version":1,"name":"origin","defaultValue":"_ALL_VALUES_","type":"CHARACTER","label":"origin","required":true},{"version":1,"name":"_action","defaultValue":"form,prompts,execute","type":"CHARACTER","label":"","required":false},{"version":1,"name":"_output_type","defaultValue":"html","type":"CHARACTER","label":"","required":false},{"version":1,"name":"_migrated_stp","defaultValue":"true","type":"CHARACTER","label":"","required":false}],"code":"/* _STARTMACROCODE_ */\n/*----------------------------------------------------------------------\n/\n/ SASStudio initialization file for SAS workspace connections\n/\n*----------------------------------------------------------------------*/\n\n/* Get the Git version */\nDATA _NULL_;\n  GITVERSION = GIT_VERSION();\n  CALL SYMPUT('_GITVERSION', GITVERSION);\nRUN;\n\n\n%MACRO resolveHomeDirectory;\n\t%GLOBAL _USERHOME;\n\t%LOCAL _HOMEVAR;\n\n\t%IF (&SYSSCP=WIN) %THEN\n\t\t%DO;\n\t\t\t%LET _HOMEVAR=USERPROFILE;\n\t\t%END;\n\t%ELSE\n\t\t%DO;\n\t\t\t%LET _HOMEVAR=HOME;\n\t\t%END;\n\n\t%LET _USERHOME= %SYSFUNC(SYSGET(&_HOMEVAR));\n\n%MEND;\n\n%resolveHomeDirectory;\n\n\n%macro web_open_file(name,type);\n%global _DATAOUT_NAME;\n%global _DATAOUT_MIME_TYPE;\n%let _DATAOUT_NAME=&name;\n%let _DATAOUT_MIME_TYPE=&type;\n%mend;\n\n%macro web_open_table(table);\n%global _DATAOUT_TABLE;\n%if %length(&_dataout_table)=0 %then %let _DATAOUT_TABLE=&table;\n%else %let _DATAOUT_TABLE=&_DATAOUT_TABLE,&table;\n%mend;\n\n%macro web_open_url(url);\n%global _DATAOUT_URL;\n%let _DATAOUT_URL=&url;\n%mend;\n\n%macro sgdesign();\n%put ERROR: SGDesigner macro can not be invoked from SAS Studio.;\n%mend;\n\n%macro sgedit();\n%put ERROR: SGEdit macro can not be invoked from SAS Studio.;\n%mend;\n\n%macro web_list_entries(catalog,type);\n\n%let typearg=;\n%let type=%upcase(&type);\n%if &type^=_ALL_ and &type^=_all_ %then %let typearg= entrytype=&type;\n\nproc catalog catalog=&catalog &typearg;\ncontents;\ntitle \"Catalog Entries in &catalog\";\nrun;\nquit;\n\n%mend;\n\n%macro web_list_catalogs(library);\n\t%let library=%upcase(&library);\n    proc sql ;\n        create table work.catalogs as select memname as Catalog, memtype as \n            Type, engine as Engine from sashelp.vmember where \n            libname=\"&library\" and memtype=\"CATALOG\";\n        run;\n        quit;\n        title \"Catalogs in &library\";\n\n    proc print data=work.catalogs;\n    run;\n%mend;\n\n%macro web_replay_grseg(catalog,entry);\nproc greplay nofs igout=&catalog;\nreplay &entry;\nrun;\n%mend;\n\n%macro sasstudio_get_zos_ds_info(DSN); \n\nOPTIONS FILESYSTEM=MVS;\n                                                                                             \nDATA work._sasstudio_dataset_info_;                                                                                                                                                                                                                                    \n                                                                                                              \n  LENGTH XDSN $32000;                                                                                                                                                                                                                            \n  XDSN=ZDSLIST('CATLG', &DSN, XVOLS, '');                                         \n                                                                                                                           \n  LENGTH XNUM 8;                                                                                                                \n  XNUM=ZDSNUM(XDSN);                                                                                                            \n  LENGTH XIDNM $4096;                                                                                                           \n  LENGTH XATTR $4096;                                                                                                           \n  LENGTH XATTRC $72;                                                                                                            \n  LENGTH XATTRN 8;  \n  LENGTH attributeType $10;\n                                                                                                            \n  DO I=1 to XNUM;                                                                                                               \n    XIDNM=ZDSIDNM(XDSN, I);                                                                                                     \n    XATTR=ZDSATTR(XIDNM, 'ALL');                                                                                                \n    XATTRN=ZDSXATT(XATTR);                                                                                                      \n                                                                                                                                           \n    do j=1 to xattrn;                                                                                                           \n     XATTRC=ZDSYATT(XATTR, j);                                                                                                  \n     blank_pos = index(xattrc,\" \");\n\t\t   key = substr(xattrc, blank_pos,99);\n\t\t   val= substr(xattrc,1,blank_pos);\n\t\t   pos = index(key, 'FILE ATTRIBUTES');\n\t\t   if (pos > 0) then do;\n\t\t      attributeType = 'FILE';\n\t\t   end;\n\t\t   else do;\n\t\t\t   pos = index(key, 'VOLUME ATTRIBUTES');\n\t\t\t   if (pos > 0) then do;\n\t\t\t      attributeType = 'VOLUME';\n\t\t\t   end;\n\t\t\t   else do;\n\t\t\t\t   pos = index(key, 'MIGRATED DATA SET ATTRIBUTES');\n\t\t\t\t   if (pos > 0) then do;\n\t\t\t\t      attributeType = 'MIGRATED';\n\t\t\t\t   end;\n\t\t\t\t   else do;\n\t\t\t\t      pos = index(key, '*****');\n\t\t\t\t   end;\n\t\t\t   end;\t\t   \n\t\t   end;\t   \n\t\t   if (pos = 0) then do;\n\t\t      output;\n\t\t   end; \n\t\t   keep key val attributeType;                                                                                                            \n    end;                                                                                                                        \n  END;                                                                                                                          \n RUN;                                                                                                                           \n%mend sasstudio_get_zos_ds_info;\n\n%macro show_zos_dataset_attributes(dsn);\n   %sasstudio_get_zos_ds_info(&dsn);\n   \n   data work._sasstudio_dataset_info_ds_;\n       set work._sasstudio_dataset_info_;\n      \n       if strip(val)='.' then do; \n           val='***NONE***';\n       end;\n     \n       position = index(attributeType, 'FILE');\n       if position > 0 then do;\n           output;\n       end;\n       drop position attributeType;\n   run;\n   \n   data work._sasstudio_dataset_info_vol_;\n       set work._sasstudio_dataset_info_;\n       \n       if strip(val)='.' then do; \n           val='***NONE***';\n       end;\n       \n       position = index(attributeType, 'VOLUME');\n       if position > 0 then do;\n           output;\n       end;\n       drop position attributeType;\n   run;\n\t\n\tproc print data=work._sasstudio_dataset_info_ds_ noobs label;\n\tLABEL key='Dataset Attribute'  val='00'x;\n\t   title1 &dsn;\n\trun;\n\t\n\tproc print data=work._sasstudio_dataset_info_vol_ noobs label;\n\t    title1;\n\t\tLABEL key='Volume Attribute'  val='00'x;\n\trun;\n\n\tproc delete data=work._sasstudio_dataset_info_\n\twork._sasstudio_dataset_info_ds_\n\twork._sasstudio_dataset_info_vol_;\n\n%mend;\n\n%macro validCasEnvironment( sessionName=, createSession=, returnCode=RC);\n\n/* This section is just to give information about the CAS connection */\n%let CASHOST = %SYSFUNC(GETOPTION(CASHOST));\n\n%if (%LENGTH(&CASHOST)=0) %then %do;\n    %put CASHOST is not set;\n%end; %else %do;\n    %put CASHOST is &CASHOST;\n%end;\n\n%let CASPORT = %SYSFUNC(GETOPTION(CASPORT));\n\n%if (&CASPORT=0) %then %do;\n    %put CASPORT is not set;\n%end; %else %do;\n    %put CASPORT is &CASPORT;\n%end;\n\n%let CASHOST = %SYSFUNC(GETOPTION(_CASHOST_));\n%if (%LENGTH(&CASHOST)=0) %then %do;\n    %put _CASHOST_ is not set;\n%end; %else %do;\n    %put _CASHOST_ is &CASHOST;\n%end;\n\n%let CASPORT = %SYSFUNC(GETOPTION(_CASPORT_));\n\n%if (%LENGTH(&CASPORT)=0) %then %do;\n    %put _CASPORT_ is not set;\n%end; %else %do;\n    %put _CASPORT_ is &CASPORT;\n%end;\n\n%let CASUSER = %SYSFUNC(GETOPTION(CASUSER));\n\n%if (%LENGTH(&CASUSER) = 0) %then %do;\n    %put CASUSER is not set;\n%end; %else %do;\n    %put CASUSER is &CASUSER;\n%end;\n\n\n%if &sessionName = %then %do;\n \t%let DEFAULTSESS= %SYSFUNC(GETOPTION(SESSREF)); \n\t%let SESSIONFOUND = %SYSFUNC(SESSFOUND(&DEFAULTSESS));\n\t%if (&SESSIONFOUND = 0) %then %do;\n\t   %put Default session &DEFAULTSESS is not available.;\n       %let &returnCode=0;\n    %end;\n    %else %do;\n\t   %put Default session &DEFAULTSESS is available.;\n       %let &returnCode=3;\n    %end;\n%end; %else %do;                                                /* Session name was specified */\n\t%if &createSession = %then %do;                             /* createSession not specified */\n\t   %let SESSIONFOUND = %SYSFUNC(SESSFOUND(&sessionName));   /* Default to false (don't create) */\n\t   %if (&SESSIONFOUND = 0) %then %do;\n\t      %put Session &sessionName is not available.;\n          %let &returnCode=0;\n       %end;\t\n       %else %do;\n          %put Session &sessionName already exists.;\n          %let &returnCode=2;\n       %end;\n    %end; \n    %else %do;\n\t   %let SESSIONFOUND = %SYSFUNC(SESSFOUND(&sessionName));  /* Does session already exist? */\n       %if (&createSession = false) %then %do;                 /* User does not want to create it. */\n          %put createSession is false;\n\t      %if (&SESSIONFOUND = 0) %then %do;\n\t         %put Session &sessionName is not available.;      /* Tell user it does not exist. */\n             %let &returnCode=0;\n          %end;\t\n          %else %do;\n             %put Session &sessionName exists;\n             %let &returnCode = 2;\n          %end;\t      \n\t   %end;\n\t   %else %do;\n         %put createSession is true;\n         %if (&SESSIONFOUND = 0) %then %do;                    /* Session does not exist, so create it */\n             cas &sessionName;\n             %let SESSIONFOUND = %SYSFUNC(SESSFOUND(&sessionName)); \n             %if (&SESSIONFOUND = 0) %then %do;               /* Session created successfully */\n                 %let &returnCode=1;\n             %end;\n             %else %do;\n                 %let &returnCode=4;                          /* Session creation failed. */\n             %end;\n         %end;\n         %else %do;                                           /* Session already exists, so user cannot create it */                                           \n             %put Session &sessionName already exists;\n             %let &returnCode=2;\n         %end;\n\t   %end;\n\t%end;\n%end;\n\n\n%mend validCasEnvironment;\n\n/* This macro is used by code generated for Query nodes in an EG Process flow *\n/* Conditionally delete set of tables or views, if they exists          */\n/* If the member does not exist, then no action is performed   */\n%macro _eg_conditional_dropds /parmbuff;\n\t\n   \t%local num;\n   \t%local stepneeded;\n   \t%local stepstarted;\n   \t%local dsname;\n\t%local name;\n\n   \t%let num=1;\n\t/* flags to determine whether a PROC SQL step is needed */\n\t/* or even started yet                                  */\n\t%let stepneeded=0;\n\t%let stepstarted=0;\n   \t%let dsname= %qscan(&syspbuff,&num,',()');\n\t%do %while(&dsname ne);\t\n\t\t%let name = %sysfunc(left(&dsname));\n\t\t%if %qsysfunc(exist(&name)) %then %do;\n\t\t\t%let stepneeded=1;\n\t\t\t%if (&stepstarted eq 0) %then %do;\n\t\t\t\tproc sql;\n\t\t\t\t%let stepstarted=1;\n\n\t\t\t%end;\n\t\t\t\tdrop table &name;\n\t\t%end;\n\n\t\t%if %sysfunc(exist(&name,view)) %then %do;\n\t\t\t%let stepneeded=1;\n\t\t\t%if (&stepstarted eq 0) %then %do;\n\t\t\t\tproc sql;\n\t\t\t\t%let stepstarted=1;\n\t\t\t%end;\n\t\t\t\tdrop view &name;\n\t\t%end;\n\t\t%let num=%eval(&num+1);\n      \t%let dsname=%qscan(&syspbuff,&num,',()');\n\t%end;\n\t%if &stepstarted %then %do;\n\t\tquit;\n\t%end;\n%mend _eg_conditional_dropds;\n\n/* Given a fileref and a memname and memtype, we attempt to open the\nmember of the directory (catalog or file system directory). We\nset &member_found to 1 if it can be opened, 0 if not. */\n%macro _entry_exists(fileref,memname,memtype);\n%global _macro_found;\n%let _macro_found = 0;\ndata _null_;\n*-----open the directory and proceed if it can be opened-----*;\nhandle = dopen(\"&fileref.\");\nif handle ne 0;\n*-----open the member and set the macro variable based on result-----*;\nmem_handle = mopen(handle,\"&memname..&memtype.\",'i');\ncall symputx('_macro_found',mem_handle ne 0);\n*-----close the member if it were opened successfully-----*;\nif mem_handle then rc = fclose(mem_handle);\n*-----close the directory-----*;\nrc = dclose(handle);\nrun;\n%mend _entry_exists;\n\n/* Given a macro name, we determine if it has already been\ncompiled. We first look in work.sasmacr, then in the sasmacr\nreferenced by sasmstore (if given) and then in work.sasmacX. */\n%macro _compiled_macro_exists(macro_name);\noptions nonotes;\n%global _macro_found;\n*-----try work.sasmacr first to see if the compiled macro is there-----*;\nfilename maclib catalog \"work.sasmacr\";\n%_entry_exists(maclib,&macro_name.,macro);\nfilename maclib clear;\n%if &_macro_found %then %goto done;\n*-----try sasmacr referenced by sasmstore if it were specified-----*;\n%let sasmstore_option = %sysfunc(getoption(sasmstore));\n%if %sysfunc(getoption(mstored))=MSTORED and %length(&sasmstore_option) > 0 %then %do;\nfilename maclib catalog \"&sasmstore_option..sasmacr\";\n%_entry_exists(maclib,&macro_name.,macro);\n%end;\n\n%do i=1 %to 9;\n%if &_macro_found %then %goto done;\nfilename maclib catalog \"work.sasmac&i.\"; \n%_entry_exists(maclib,&macro_name.,macro);\nfilename maclib clear; \n%end;\n\n%done: options notes;\n%mend _compiled_macro_exists;\n\n%macro studio_cas_start;\n\n%global _macro_found;\n%global syscasinit;\n\n%let syscasinit=0;\n\n%_compiled_macro_exists(studio_cas_init);\n\n%if &_macro_found %then %do;\n\n%let syscasinit=1;\n\n%studio_cas_init;\n\n%end;\n%mend studio_cas_start;\n\n%macro studio_hide_wrapper;\n\t%global _studionotes;\n\t%global _studiosource;\n\t%global _studiostimer;\n\n    %if &_studionotes = %then %do;\n\t    %let _studionotes=%sysfunc(getoption(notes));\n\t%end;\n\toptions nonotes;\n\n    %if &_studiosource = %then %do;\n\t    %let _studiosource=%sysfunc(getoption(source));\n\t%end;\n\toptions nosource;\n\n    %if &_studiostimer = %then %do;\n\t    %let _studiostimer=%sysfunc(getoption(stimer));\n\t%end;\n    options nostimer;\n%mend studio_hide_wrapper;\n\n%macro studio_show_wrapper;\n\t%global _studionotes;\n\t%global _studiosource;\n\t%global _studiostimer;\n\n    %if &_studionotes = %then %do;\n\t    %let _studionotes=%sysfunc(getoption(notes));\n\t%end;\n\toptions notes;\n\n    %if &_studiosource = %then %do;\n\t    %let _studiosource=%sysfunc(getoption(source));\n\t%end;\n\toptions source;\n\n    %if &_studiostimer = %then %do;\n\t    %let _studiostimer=%sysfunc(getoption(stimer));\n\t%end;\n    options stimer;\n%mend studio_show_wrapper;\n\n%macro studio_show_only_notes_wrapper;\n\t%global _studionotes;\n\t%global _studiosource;\n\t%global _studiostimer;\n\n    %if &_studionotes = %then %do;\n\t    %let _studionotes=%sysfunc(getoption(notes));\n\t%end;\n\toptions notes;\n\n    %if &_studiosource = %then %do;\n\t    %let _studiosource=%sysfunc(getoption(source));\n\t%end;\n\toptions nosource;\n\n    %if &_studiostimer = %then %do;\n\t    %let _studiostimer=%sysfunc(getoption(stimer));\n\t%end;\n    options nostimer;\n%mend studio_show_only_notes_wrapper;\n\n\n%macro studio_restore_wrapper;\n    %global _studionotes;\n    %global _studiosource;\n    %global _studiostimer;\n\n\toptions &_studionotes;\n\toptions &_studiosource;\n\toptions &_studiostimer;\n\n\t/* Clear out values so we know they have been restored */\n\t%let _studionotes=;\n\t%let _studiosource=;\n\t%let _studiostimer=;\n%mend studio_restore_wrapper;\n\noptions timezone='GMT-04:00';\n%let requestedlocale=en-US;\n%let validlocale=%SYSFUNC(getpxlocale(&requestedlocale));\n%let validlocale=%trim(&validlocale);\n%if %length(&validlocale) > 0 %then %do;options locale=&validlocale DFLANG=LOCALE;%end; %else %do;options locale=en_US DFLANG=LOCALE;%end;DATA _NULL_;\n\tID=SYMGET(\"SYSUSERID\");\n\tCALL SYMPUT(\"SYSUSERNAME\",ID);\n\tRC=TSLVL('UWUUSERN','N');\n\t_ERROR_=0;\n\tIF (RC^=' ') THEN DO;\n\t\tcall execute(\"DATA _NULL_;NAME=USERNAME();CALL SYMPUT('SYSUSERNAME',NAME);RUN;\");\n\tEND;\nRUN;\n\nFILENAME _keepalv TEMP;\n\noptions validvarname=any;\noptions validmemname=extend;\n\n/* _ENDMACROCODE_ */\n*  Begin EG generated code (do not edit this line); \n* \n*  Stored process registered by \n*  Enterprise Guide Stored Process Manager V8.3 \n* \n*  ==================================================================== \n*  Stored process name: Fuel Efficiency by Type and Origin \n*  ==================================================================== \n* \n*  Stored process prompt dictionary: \n*  ____________________________________ \n*  ORIGIN \n*       Type: Text \n*      Label: origin \n*       Attr: Visible, Required \n*    Default: <ALL> \n*  ____________________________________ \n*; \n \n \n*ProcessBody; \n \n%global ORIGIN; \n \n%STPBEGIN; \n \n*  End EG generated code (do not edit this line); \n \n \n/* --- Start of shared macro functions. --- */ \n/* Conditionally delete set of tables or views, if they exists          */ \n/* If the member does not exist, then no action is performed   */ \n%macro _eg_conditional_dropds /parmbuff; \n  \n    %local num; \n    %local stepneeded; \n    %local stepstarted; \n    %local dsname; \n %local name; \n \n    %let num=1; \n /* flags to determine whether a PROC SQL step is needed */ \n /* or even started yet                                  */ \n %let stepneeded=0; \n %let stepstarted=0; \n    %let dsname= %qscan(&syspbuff,&num,',()'); \n %do %while(&dsname ne);  \n  %let name = %sysfunc(left(&dsname)); \n  %if %qsysfunc(exist(&name)) %then %do; \n   %let stepneeded=1; \n   %if (&stepstarted eq 0) %then %do; \n    proc sql; \n    %let stepstarted=1; \n \n   %end; \n    drop table &name; \n  %end; \n \n  %if %sysfunc(exist(&name,view)) %then %do; \n   %let stepneeded=1; \n   %if (&stepstarted eq 0) %then %do; \n    proc sql; \n    %let stepstarted=1; \n   %end; \n    drop view &name; \n  %end; \n  %let num=%eval(&num+1); \n       %let dsname=%qscan(&syspbuff,&num,',()'); \n %end; \n %if &stepstarted %then %do; \n  quit; \n %end; \n%mend _eg_conditional_dropds; \n \n/* Build where clauses from stored process parameters */ \n%macro _eg_WhereParam( COLUMN, PARM, OPERATOR, TYPE=S, MATCHALL=-ALL-, MATCHALL_CLAUSE=1, MAX= , IS_EXPLICIT=0, MATCH_CASE=1); \n \n  %local q1 q2 sq1 sq2; \n  %local isEmpty; \n  %local isEqual isNotEqual; \n  %local isIn isNotIn; \n  %local isString; \n  %local isBetween; \n \n  %let isEqual = (\"%QUPCASE(&OPERATOR)\" = \"EQ\" OR \"&OPERATOR\" = \"=\"); \n  %let isNotEqual = (\"%QUPCASE(&OPERATOR)\" = \"NE\" OR \"&OPERATOR\" = \"<>\"); \n  %let isIn = (\"%QUPCASE(&OPERATOR)\" = \"IN\"); \n  %let isNotIn = (\"%QUPCASE(&OPERATOR)\" = \"NOT IN\"); \n  %let isString = (%QUPCASE(&TYPE) eq S or %QUPCASE(&TYPE) eq STRING ); \n  %if &isString %then \n  %do; \n %if \"&MATCH_CASE\" eq \"0\" %then %do; \n  %let COLUMN = %str(UPPER%(&COLUMN%)); \n %end; \n %let q1=%str(%\"); \n %let q2=%str(%\"); \n %let sq1=%str(%');  \n %let sq2=%str(%');  \n  %end; \n  %else %if %QUPCASE(&TYPE) eq D or %QUPCASE(&TYPE) eq DATE %then  \n  %do; \n    %let q1=%str(%\"); \n    %let q2=%str(%\"d); \n %let sq1=%str(%');  \n    %let sq2=%str(%');  \n  %end; \n  %else %if %QUPCASE(&TYPE) eq T or %QUPCASE(&TYPE) eq TIME %then \n  %do; \n    %let q1=%str(%\"); \n    %let q2=%str(%\"t); \n %let sq1=%str(%');  \n    %let sq2=%str(%');  \n  %end; \n  %else %if %QUPCASE(&TYPE) eq DT or %QUPCASE(&TYPE) eq DATETIME %then \n  %do; \n    %let q1=%str(%\"); \n    %let q2=%str(%\"dt); \n %let sq1=%str(%');  \n    %let sq2=%str(%');  \n  %end; \n  %else \n  %do; \n    %let q1=; \n    %let q2=; \n %let sq1=; \n    %let sq2=; \n  %end; \n   \n  %if \"&PARM\" = \"\" %then %let PARM=&COLUMN; \n \n  %let isBetween = (\"%QUPCASE(&OPERATOR)\"=\"BETWEEN\" or \"%QUPCASE(&OPERATOR)\"=\"NOT BETWEEN\"); \n \n  %if \"&MAX\" = \"\" %then %do; \n    %let MAX = &parm._MAX; \n    %if &isBetween %then %let PARM = &parm._MIN; \n  %end; \n \n  %if not %symexist(&PARM) or (&isBetween and not %symexist(&MAX)) %then %do; \n    %if &IS_EXPLICIT=0 %then %do; \n  not &MATCHALL_CLAUSE \n %end; \n %else %do; \n     not 1=1 \n %end; \n  %end; \n  %else %if \"%qupcase(&&&PARM)\" = \"%qupcase(&MATCHALL)\" %then %do; \n    %if &IS_EXPLICIT=0 %then %do; \n     &MATCHALL_CLAUSE \n %end; \n %else %do; \n     1=1 \n %end;  \n  %end; \n  %else %if (not %symexist(&PARM._count)) or &isBetween %then %do; \n    %let isEmpty = (\"&&&PARM\" = \"\"); \n    %if (&isEqual AND &isEmpty AND &isString) %then \n       &COLUMN is null; \n    %else %if (&isNotEqual AND &isEmpty AND &isString) %then \n       &COLUMN is not null; \n    %else %do; \n    %if &IS_EXPLICIT=0 %then %do; \n           &COLUMN &OPERATOR  \n   %if \"&MATCH_CASE\" eq \"0\" %then %do; \n    %unquote(&q1)%QUPCASE(&&&PARM)%unquote(&q2) \n   %end; \n   %else %do; \n    %unquote(&q1)&&&PARM%unquote(&q2) \n   %end; \n    %end; \n    %else %do; \n        &COLUMN &OPERATOR  \n   %if \"&MATCH_CASE\" eq \"0\" %then %do; \n    %unquote(%nrstr(&sq1))%QUPCASE(&&&PARM)%unquote(%nrstr(&sq2)) \n   %end; \n   %else %do; \n    %unquote(%nrstr(&sq1))&&&PARM%unquote(%nrstr(&sq2)) \n   %end; \n    %end; \n       %if &isBetween %then  \n          AND %unquote(&q1)&&&MAX%unquote(&q2); \n    %end; \n  %end; \n  %else  \n  %do; \n %local emptyList; \n   %let emptyList = %symexist(&PARM._count); \n   %if &emptyList %then %let emptyList = &&&PARM._count = 0; \n %if (&emptyList) %then \n %do; \n  %if (&isNotin) %then \n     1; \n  %else \n   0; \n %end; \n %else %if (&&&PARM._count = 1) %then  \n    %do; \n      %let isEmpty = (\"&&&PARM\" = \"\"); \n      %if (&isIn AND &isEmpty AND &isString) %then \n        &COLUMN is null; \n      %else %if (&isNotin AND &isEmpty AND &isString) %then \n        &COLUMN is not null; \n      %else %do; \n     %if &IS_EXPLICIT=0 %then %do; \n   %if \"&MATCH_CASE\" eq \"0\" %then %do; \n    &COLUMN &OPERATOR (%unquote(&q1)%QUPCASE(&&&PARM)%unquote(&q2)) \n   %end; \n   %else %do; \n    &COLUMN &OPERATOR (%unquote(&q1)&&&PARM%unquote(&q2)) \n   %end; \n     %end; \n  %else %do; \n      &COLUMN &OPERATOR ( \n   %if \"&MATCH_CASE\" eq \"0\" %then %do; \n    %unquote(%nrstr(&sq1))%QUPCASE(&&&PARM)%unquote(%nrstr(&sq2))) \n   %end; \n   %else %do; \n    %unquote(%nrstr(&sq1))&&&PARM%unquote(%nrstr(&sq2))) \n   %end; \n  %end; \n   %end; \n    %end; \n    %else  \n    %do; \n       %local addIsNull addIsNotNull addComma; \n       %let addIsNull = %eval(0); \n       %let addIsNotNull = %eval(0); \n       %let addComma = %eval(0); \n       (&COLUMN &OPERATOR (  \n       %do i=1 %to &&&PARM._count;  \n          %let isEmpty = (\"&&&PARM&i\" = \"\"); \n          %if (&isString AND &isEmpty AND (&isIn OR &isNotIn)) %then \n          %do; \n             %if (&isIn) %then %let addIsNull = 1; \n             %else %let addIsNotNull = 1; \n          %end; \n          %else \n          %do;        \n            %if &addComma %then %do;,%end; \n   %if &IS_EXPLICIT=0 %then %do; \n    %if \"&MATCH_CASE\" eq \"0\" %then %do; \n     %unquote(&q1)%QUPCASE(&&&PARM&i)%unquote(&q2) \n    %end; \n    %else %do; \n     %unquote(&q1)&&&PARM&i%unquote(&q2) \n    %end; \n   %end; \n   %else %do; \n    %if \"&MATCH_CASE\" eq \"0\" %then %do; \n     %unquote(%nrstr(&sq1))%QUPCASE(&&&PARM&i)%unquote(%nrstr(&sq2)) \n    %end; \n    %else %do; \n     %unquote(%nrstr(&sq1))&&&PARM&i%unquote(%nrstr(&sq2)) \n    %end;  \n   %end; \n            %let addComma = %eval(1); \n          %end; \n       %end;)  \n       %if &addIsNull %then OR &COLUMN is null; \n       %else %if &addIsNotNull %then AND &COLUMN is not null; \n       %do;) \n       %end; \n    %end; \n  %end; \n%mend _eg_WhereParam; \n \n/* --- End of shared macro functions. --- */ \n \n/* --- Start of code for \"Query Builder\". --- */ \n%_eg_conditional_dropds(WORK.QUERY_FOR_CARS); \n \nPROC SQL; \n   CREATE TABLE WORK.QUERY_FOR_CARS AS  \n   SELECT t1.Make,  \n          t1.Model,  \n          t1.Type,  \n          t1.Origin,  \n          t1.DriveTrain,  \n          t1.MSRP,  \n          t1.Invoice,  \n          t1.EngineSize,  \n          t1.Cylinders,  \n          t1.Horsepower,  \n          t1.MPG_City,  \n          t1.MPG_Highway,  \n          t1.Weight,  \n          t1.Wheelbase,  \n          t1.Length \n      FROM SASHELP.CARS t1 \n      WHERE %_eg_WhereParam( t1.Origin, origin, EQ, TYPE=S, IS_EXPLICIT=0 ); \nQUIT; \n/* --- End of code for \"Query Builder\". --- */ \n \n/* --- Start of code for \"Summary Statistics\". --- */ \n/* ------------------------------------------------------------------- \n   Code generated by SAS Task \n \n   Generated on: Monday, August 28, 2023 at 2:12:08 AM \n   By task: Summary Statistics \n \n   Input Data: SASApp:WORK.QUERY_FOR_CARS \n   Server:  SASApp \n   ------------------------------------------------------------------- */ \n \n \n/* Start of custom user code */ \nods noproctitle; \n/* End of custom user code */ \n%_eg_conditional_dropds(WORK.SORTTempTableSorted); \n/* ------------------------------------------------------------------- \n   Sort data set SASApp:WORK.QUERY_FOR_CARS \n   ------------------------------------------------------------------- */ \n \nPROC SQL; \n CREATE VIEW WORK.SORTTempTableSorted AS \n  SELECT T.MPG_Highway, T.Type \n FROM WORK.QUERY_FOR_CARS as T \n; \nQUIT; \n/* ------------------------------------------------------------------- \n   Run the Means Procedure \n   ------------------------------------------------------------------- */ \nTITLE; \nTITLE1 \"Summary statistics grouped by Type  for Origin &origin\"; \nFOOTNOTE; \nPROC MEANS DATA=WORK.SORTTempTableSorted \n FW=12 \n PRINTALLTYPES \n CHARTYPE \n NWAY \n VARDEF=DF   \n  MEAN  \n  STD  \n  MIN  \n  MAX  \n  N ; \n VAR MPG_Highway; \n CLASS Type / ORDER=UNFORMATTED ASCENDING; \n \nRUN; \nODS GRAPHICS ON; \nTITLE; \nTITLE1 \"Summary Statistics\"; \nTITLE2 \"Box and Whisker Plots\"; \nPROC SGPLOT DATA=WORK.SORTTempTableSorted ; \n VBOX MPG_Highway / category=Type; \nRUN;QUIT; \nODS GRAPHICS OFF; \n/* ------------------------------------------------------------------- \n   End of task code \n   ------------------------------------------------------------------- */ \nRUN; QUIT; \n%_eg_conditional_dropds(WORK.SORTTempTableSorted); \nTITLE; FOOTNOTE; \n \n/* --- End of code for \"Summary Statistics\". --- */ \n \n*  Begin EG generated code (do not edit this line); \n;*';*\";*/;quit; \n%STPEND; \n \n*  End EG generated code (do not edit this line); \n","links":[{"method":"GET","rel":"self","href":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","uri":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","type":"application/vnd.sas.job.definition"},{"method":"GET","rel":"alternate","href":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","uri":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","type":"application/vnd.sas.summary"},{"method":"PUT","rel":"update","href":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","uri":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","type":"application/vnd.sas.job.definition","responseType":"application/vnd.sas.job.definition"},{"method":"DELETE","rel":"delete","href":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb","uri":"/jobDefinitions/definitions/b4d3cd6e-186d-48ff-909d-53e351280dbb"}],"properties":[{"name":"form","value":""},{"name":"pathLabel","value":"/VJOB/Fuel Efficiency by Type and Origin"},{"name":"prompts","value":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<Task schemaVersion=\"7.2\">\n    <!--Generated by Prompt Converter 1.2-->\n    <!--WARNING:Prompt xml does not currently support Special or Missing values as a default value. The default value will be cleared. (promptName=origin, promptID=PromptDef_1693188451540_790923)-->\n    <Registration>\n        <Name>Conversion Task</Name>\n        <Description>SAS Version 9 Prompt to SPI converter</Description>\n        <Version>5.11</Version>\n    </Registration>\n    <Metadata>\n        <Options>\n            <!--group option \"General\"-->\n            <Option inputType=\"string\" name=\"Option0\">General</Option>\n            <!--combobox option for promptName=\"origin\", promptID=\"PromptDef_1693188451540_790923\"-->\n            <Option allowAllValues=\"true\" editable=\"false\" inputType=\"combobox\" name=\"origin\" required=\"true\">origin</Option>\n            <Option inputType=\"string\" name=\"Option1\" returnValue=\"Asia\">Asia</Option>\n            <Option inputType=\"string\" name=\"Option2\" returnValue=\"Europe\">Europe</Option>\n            <Option inputType=\"string\" name=\"Option3\" returnValue=\"USA\">USA</Option>\n        </Options>\n        <DataSources/>\n    </Metadata>\n    <UI>\n        <OptionItem option=\"Option0\"/>\n        <!--combobox option-->\n        <OptionChoice option=\"origin\">\n            <OptionItem option=\"Option1\"/>\n            <OptionItem option=\"Option2\"/>\n            <OptionItem option=\"Option3\"/>\n        </OptionChoice>\n    </UI>\n    <OptionDependencies/>\n</Task>\n"}]}
